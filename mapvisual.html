<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Senedd 2026 GeoJSON SVG with Zoom, Pan & Proper Aspect Ratio</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    overflow: hidden;
    position: relative;
  }
  svg {
    width: 100vw;
    height: 100vh;
    background: #f0f0f0;
    user-select: none; /* prevent text selection while dragging */
    cursor: grab;
  }
  svg:active {
    cursor: grabbing;
  }
  path.constituency {
    fill: steelblue;
    stroke: white;
    stroke-width: 1.5;
    fill-opacity: 0.6;
    cursor: pointer;
    transition: fill-opacity 0.3s, fill 0.3s;
  }
  path.constituency:hover {
    fill: orange;
    fill-opacity: 0.9;
  }
  #tooltip {
    position: absolute;
    padding: 6px 10px;
    background: rgba(0,0,0,0.75);
    color: white;
    border-radius: 4px;
    pointer-events: none;
    font-size: 14px;
    opacity: 0;
    transition: opacity 0.2s;
    white-space: nowrap;
    z-index: 10;
  }
</style>
</head>
<body>

<div id="tooltip"></div>
<svg id="map">
  <g id="content"></g>
</svg>

<script>
  const svg = document.getElementById('map');
  const content = document.getElementById('content');
  const tooltip = document.getElementById('tooltip');

  let width = window.innerWidth;
  let height = window.innerHeight;

  // Geographic bounds for Wales (adjust if needed)
  const lonMin = -5.5, lonMax = -2;
  const latMin = 51.3, latMax = 53.6;

  // Calculate geographic and SVG aspect ratios
  const geoWidth = lonMax - lonMin;
  const geoHeight = latMax - latMin;
  const geoAspect = geoWidth / geoHeight;
  const svgAspect = width / height;

  let scaleX, scaleY, scale, offsetX, offsetY;

  if (svgAspect > geoAspect) {
    // SVG is wider than geography; fit height and center horizontally
    scale = height / geoHeight;
    scaleX = scale;
    scaleY = scale;
    offsetX = (width - geoWidth * scale) / 2;
    offsetY = 0;
  } else {
    // SVG is taller; fit width and center vertically
    scale = width / geoWidth;
    scaleX = scale;
    scaleY = scale;
    offsetX = 0;
    offsetY = (height - geoHeight * scale) / 2;
  }

  // Projection function with aspect ratio fix and centering
  function project([lon, lat]) {
    const x = (lon - lonMin) * scaleX + offsetX;
    // Latitude decreases as Y increases, so invert Y axis here
    const y = height - ((lat - latMin) * scaleY + offsetY);
    return [x, y];
  }

  function createPath(coords) {
    if (!coords) return '';

    if (typeof coords[0][0] === 'number') {
      return coords.map(point => {
        const [x, y] = project(point);
        return `${x},${y}`;
      }).join(' ');
    } else {
      let d = '';
      coords.forEach(ring => {
        d += 'M' + createPath(ring) + 'Z ';
      });
      return d.trim();
    }
  }

  function geoJSONToSVGPath(feature) {
    const geom = feature.geometry;
    if (!geom) return '';

    if (geom.type === 'Polygon') {
      const rings = geom.coordinates;
      return rings.map(ring => 'M' + createPath(ring) + 'Z').join(' ');
    } else if (geom.type === 'MultiPolygon') {
      const polygons = geom.coordinates;
      return polygons.map(polygon =>
        polygon.map(ring => 'M' + createPath(ring) + 'Z').join(' ')
      ).join(' ');
    }
    return '';
  }

  // Zoom and pan state
  let scaleFactor = 1;
  let translateX = 0;
  let translateY = 0;
  let isDragging = false;
  let dragStart = null;

  function updateTransform() {
    content.setAttribute('transform', `translate(${translateX},${translateY}) scale(${scaleFactor})`);
  }

  // Zoom on wheel
  svg.addEventListener('wheel', e => {
    e.preventDefault();

    const zoomIntensity = 0.1;
    const direction = e.deltaY > 0 ? -1 : 1;

    const rect = svg.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const newScale = Math.min(Math.max(scaleFactor + direction * zoomIntensity * scaleFactor, 0.5), 10);

    translateX -= (mx - translateX) * (newScale / scaleFactor - 1);
    translateY -= (my - translateY) * (newScale / scaleFactor - 1);

    scaleFactor = newScale;
    updateTransform();
  });

  // Pan on drag
  svg.addEventListener('mousedown', e => {
    isDragging = true;
    dragStart = { x: e.clientX - translateX, y: e.clientY - translateY };
  });
  window.addEventListener('mouseup', () => {
    isDragging = false;
  });
  window.addEventListener('mousemove', e => {
    if (!isDragging) return;
    translateX = e.clientX - dragStart.x;
    translateY = e.clientY - dragStart.y;
    updateTransform();
  });

  // Load and render GeoJSON
  fetch('senedd2026.json')
    .then(res => {
      if (!res.ok) throw new Error('Could not load GeoJSON');
      return res.json();
    })
    .then(data => {
      data.features.forEach(feature => {
        const pathData = geoJSONToSVGPath(feature);
        if (!pathData) return;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathData);
        path.setAttribute('class', 'constituency');
        path.setAttribute('data-name', feature.properties.name || 'Unknown');

        path.addEventListener('mousemove', e => {
          tooltip.style.opacity = 1;
          tooltip.style.left = (e.pageX + 10) + 'px';
          tooltip.style.top = (e.pageY + 10) + 'px';
          tooltip.textContent = path.getAttribute('data-name');
        });
        path.addEventListener('mouseout', () => {
          tooltip.style.opacity = 0;
        });

        content.appendChild(path);
      });
      updateTransform();
    })
    .catch(err => {
      console.error('Error loading or processing GeoJSON:', err);
    });

  // Initial SVG size
  svg.setAttribute('width', width);
  svg.setAttribute('height', height);

  // Adjust size & recalc on resize
  window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;

    const newSvgAspect = width / height;
    if (newSvgAspect > geoAspect) {
      scale = height / geoHeight;
      scaleX = scale;
      scaleY = scale;
      offsetX = (width - geoWidth * scale) / 2;
      offsetY = 0;
    } else {
      scale = width / geoWidth;
      scaleX = scale;
      scaleY = scale;
      offsetX = 0;
      offsetY = (height - geoHeight * scale) / 2;
    }

    svg.setAttribute('width', width);
    svg.setAttribute('height', height);

    // Re-render paths' d attribute with new projection
    // This is an extra step: if you want paths to resize properly on window resize,
    // you might want to clear and re-load or re-project paths here.
    // For simplicity, this example keeps existing paths, so map may stretch on resize.
    // If you want, I can help implement a full resize + re-project logic.
  });
</script>

</body>
</html>
