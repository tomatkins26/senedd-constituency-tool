<script>
  const svg = document.getElementById('map');
  const content = document.getElementById('content');
  const tooltip = document.getElementById('tooltip');

  let width = window.innerWidth;
  let height = window.innerHeight;

  let lonMin, lonMax, latMin, latMax;

  // Utility to flatten all coordinates in GeoJSON for bounding box calc
  function flattenCoords(geometry) {
    let coords = [];
    if (!geometry) return coords;

    if (geometry.type === 'Polygon') {
      geometry.coordinates.forEach(ring => {
        coords = coords.concat(ring);
      });
    } else if (geometry.type === 'MultiPolygon') {
      geometry.coordinates.forEach(polygon => {
        polygon.forEach(ring => {
          coords = coords.concat(ring);
        });
      });
    }
    return coords;
  }

  // Calculate bounding box from GeoJSON features
  function calculateBounds(features) {
    let lons = [];
    let lats = [];

    features.forEach(feature => {
      const coords = flattenCoords(feature.geometry);
      coords.forEach(([lon, lat]) => {
        lons.push(lon);
        lats.push(lat);
      });
    });

    return {
      lonMin: Math.min(...lons),
      lonMax: Math.max(...lons),
      latMin: Math.min(...lats),
      latMax: Math.max(...lats)
    };
  }

  // Projection variables (to be set after loading GeoJSON)
  let scaleX, scaleY, scale, offsetX, offsetY;

  function setupProjection(bounds) {
    lonMin = bounds.lonMin;
    lonMax = bounds.lonMax;
    latMin = bounds.latMin;
    latMax = bounds.latMax;

    const geoWidth = lonMax - lonMin;
    const geoHeight = latMax - latMin;
    const geoAspect = geoWidth / geoHeight;
    const svgAspect = width / height;

    if (svgAspect > geoAspect) {
      scale = height / geoHeight;
      scaleX = scale;
      scaleY = scale;
      offsetX = (width - geoWidth * scale) / 2;
      offsetY = 0;
    } else {
      scale = width / geoWidth;
      scaleX = scale;
      scaleY = scale;
      offsetX = 0;
      offsetY = (height - geoHeight * scale) / 2;
    }
  }

  function project([lon, lat]) {
    const x = (lon - lonMin) * scaleX + offsetX;
    const y = height - ((lat - latMin) * scaleY + offsetY);
    return [x, y];
  }

  function createPath(coords) {
    if (!coords) return '';

    if (typeof coords[0][0] === 'number') {
      return coords.map(point => {
        const [x, y] = project(point);
        return `${x},${y}`;
      }).join(' ');
    } else {
      let d = '';
      coords.forEach(ring => {
        d += 'M' + createPath(ring) + 'Z ';
      });
      return d.trim();
    }
  }

  function geoJSONToSVGPath(feature) {
    const geom = feature.geometry;
    if (!geom) return '';

    if (geom.type === 'Polygon') {
      const rings = geom.coordinates;
      return rings.map(ring => 'M' + createPath(ring) + 'Z').join(' ');
    } else if (geom.type === 'MultiPolygon') {
      const polygons = geom.coordinates;
      return polygons.map(polygon =>
        polygon.map(ring => 'M' + createPath(ring) + 'Z').join(' ')
      ).join(' ');
    }
    return '';
  }

  // Zoom and pan state
  let scaleFactor = 1;
  let translateX = 0;
  let translateY = 0;
  let isDragging = false;
  let dragStart = null;

  function updateTransform() {
    content.setAttribute('transform', `translate(${translateX},${translateY}) scale(${scaleFactor})`);
  }

  // Zoom on wheel
  svg.addEventListener('wheel', e => {
    e.preventDefault();

    const zoomIntensity = 0.1;
    const direction = e.deltaY > 0 ? -1 : 1;

    const rect = svg.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const newScale = Math.min(Math.max(scaleFactor + direction * zoomIntensity * scaleFactor, 0.5), 10);

    translateX -= (mx - translateX) * (newScale / scaleFactor - 1);
    translateY -= (my - translateY) * (newScale / scaleFactor - 1);

    scaleFactor = newScale;
    updateTransform();
  });

  // Pan on drag
  svg.addEventListener('mousedown', e => {
    isDragging = true;
    dragStart = { x: e.clientX - translateX, y: e.clientY - translateY };
  });
  window.addEventListener('mouseup', () => {
    isDragging = false;
  });
  window.addEventListener('mousemove', e => {
    if (!isDragging) return;
    translateX = e.clientX - dragStart.x;
    translateY = e.clientY - dragStart.y;
    updateTransform();
  });

  // Load GeoJSON and render
  fetch('senedd2026.json')
    .then(res => {
      if (!res.ok) throw new Error('Could not load GeoJSON');
      return res.json();
    })
    .then(data => {
      const bounds = calculateBounds(data.features);
      setupProjection(bounds);

      data.features.forEach(feature => {
        const pathData = geoJSONToSVGPath(feature);
        if (!pathData) return;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathData);
        path.setAttribute('class', 'constituency');
        path.setAttribute('data-name', feature.properties.name || 'Unknown');

        path.addEventListener('mousemove', e => {
          tooltip.style.opacity = 1;
          tooltip.style.left = (e.pageX + 10) + 'px';
          tooltip.style.top = (e.pageY + 10) + 'px';
          tooltip.textContent = path.getAttribute('data-name');
        });
        path.addEventListener('mouseout', () => {
          tooltip.style.opacity = 0;
        });

        content.appendChild(path);
      });
      updateTransform();
    })
    .catch(err => {
      console.error('Error loading or processing GeoJSON:', err);
    });

  // Set SVG size
  svg.setAttribute('width', width);
  svg.setAttribute('height', height);

  // On resize, update width/height but this example skips reprojecting for simplicity
  window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
  });
</script>
