<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Senedd 2026 GeoJSON SVG Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    overflow: hidden;
    position: relative;
  }
  svg {
    width: 100vw;
    height: 100vh;
    background: #f0f0f0;
  }
  path.constituency {
    fill: steelblue;
    stroke: white;
    stroke-width: 1.5;
    fill-opacity: 0.6;
    cursor: pointer;
    transition: fill-opacity 0.3s, fill 0.3s;
  }
  path.constituency:hover {
    fill: orange;
    fill-opacity: 0.9;
  }
  #tooltip {
    position: absolute;
    padding: 6px 10px;
    background: rgba(0,0,0,0.75);
    color: white;
    border-radius: 4px;
    pointer-events: none;
    font-size: 14px;
    opacity: 0;
    transition: opacity 0.2s;
    white-space: nowrap;
    z-index: 10;
  }
</style>
</head>
<body>

<div id="tooltip"></div>
<svg id="map"></svg>

<script>
  const svg = document.getElementById('map');
  const tooltip = document.getElementById('tooltip');

  // A very simple projection function to convert [lon, lat] to [x, y]
  // This is a rough equirectangular projection scaled to fit SVG width & height.
  // You might want to tweak scale and translate for your area.
  const width = window.innerWidth;
  const height = window.innerHeight;

  // Bounds of your area (Wales roughly) - adjust if needed
  const lonMin = -5.5, lonMax = -2;
  const latMin = 51.3, latMax = 53.6;

  function project([lon, lat]) {
    // Normalize longitude and latitude within bounds and map to SVG coords
    const x = ((lon - lonMin) / (lonMax - lonMin)) * width;
    const y = height - ((lat - latMin) / (latMax - latMin)) * height;
    return [x, y];
  }

  function createPath(coords) {
    if (!coords) return '';

    // GeoJSON polygons can be nested arrays:
    // Polygon: array of linear rings (exterior + holes)
    // MultiPolygon: array of polygons

    if (typeof coords[0][0] === 'number') {
      // It's a LinearRing (Polygon ring)
      return coords.map(point => {
        const [x, y] = project(point);
        return `${x},${y}`;
      }).join(' ');
    } else {
      // It's MultiPolygon or Polygon with holes
      // Recursively build path data for all rings
      let d = '';
      coords.forEach(ring => {
        d += 'M' + createPath(ring) + 'Z ';
      });
      return d.trim();
    }
  }

  function geoJSONToSVGPath(feature) {
    const geom = feature.geometry;
    if (!geom) return '';

    if (geom.type === 'Polygon') {
      const rings = geom.coordinates;
      return rings.map(ring => 'M' + createPath(ring) + 'Z').join(' ');
    } else if (geom.type === 'MultiPolygon') {
      const polygons = geom.coordinates;
      return polygons.map(polygon =>
        polygon.map(ring => 'M' + createPath(ring) + 'Z').join(' ')
      ).join(' ');
    }
    return '';
  }

  // Load the GeoJSON file
  fetch('senedd2026.json')
    .then(res => {
      if (!res.ok) throw new Error('Could not load GeoJSON');
      return res.json();
    })
    .then(data => {
      data.features.forEach(feature => {
        const pathData = geoJSONToSVGPath(feature);
        if (!pathData) return;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathData);
        path.setAttribute('class', 'constituency');
        path.setAttribute('data-name', feature.properties.name || 'Unknown');

        // Mouse events for tooltip and hover effect (hover handled by CSS)
        path.addEventListener('mousemove', e => {
          tooltip.style.opacity = 1;
          tooltip.style.left = (e.pageX + 10) + 'px';
          tooltip.style.top = (e.pageY + 10) + 'px';
          tooltip.textContent = path.getAttribute('data-name');
        });
        path.addEventListener('mouseout', () => {
          tooltip.style.opacity = 0;
        });

        svg.appendChild(path);
      });
    })
    .catch(err => {
      console.error('Error loading or processing GeoJSON:', err);
    });

  // Optional: resize SVG and recalc if window size changes
  window.addEventListener('resize', () => {
    svg.setAttribute('width', window.innerWidth);
    svg.setAttribute('height', window.innerHeight);
  });
  svg.setAttribute('width', width);
  svg.setAttribute('height', height);

</script>

</body>
</html>
