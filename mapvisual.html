<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body, html {
    margin: 0; padding: 0; height: 100vh; overflow: hidden;
    display: flex; justify-content: center; align-items: center;
    background: #f0f0f0;
    user-select: none;
  }
  svg {
    border: 1px solid #ccc;
    background: white;
    touch-action: none;
  }
  polygon {
    cursor: pointer;
    transition: fill 0.3s ease;
    stroke: white;
    stroke-width: 1.5;
    fill: #0B3D91; /* ITV News dark blue */
  }
  polygon:hover {
    fill: #E4002B; /* ITV News red on hover */
  }
  #tooltip {
    position: fixed;
    pointer-events: none;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 4px 8px;
    font-family: sans-serif;
    font-size: 14px;
    border-radius: 4px;
    white-space: nowrap;
    display: none;
  }
</style>
</head>
<body>

<svg id="map" width="90vw" height="90vh" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet"></svg>
<div id="tooltip"></div>

<script>
(() => {
  const svg = document.getElementById('map');
  const tooltip = document.getElementById('tooltip');
  const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  svg.appendChild(g);

  // Zoom & pan state
  let zoom = 1;
  let offsetX = 0;
  let offsetY = 0;
  let isDragging = false;
  let dragStart = null;

  // === Embed your full senedd2026.json content here ===
  // Replace this example with your real data
  const data = {
    "type": "FeatureCollection",
    "features": [
      {
        "type": "Feature",
        "properties": { "name": "Constituency A" },
        "geometry": {
          "type": "Polygon",
          "coordinates": [[
            [-3, 51],
            [-3, 52],
            [-2, 52],
            [-2, 51],
            [-3, 51]
          ]]
        }
      },
      {
        "type": "Feature",
        "properties": { "name": "Constituency B" },
        "geometry": {
          "type": "Polygon",
          "coordinates": [[
            [-2, 51],
            [-2, 52],
            [-1, 52],
            [-1, 51],
            [-2, 51]
          ]]
        }
      }
    ]
  };

  function drawMap(data) {
    // Extract all coordinates
    let allCoords = [];
    data.features.forEach(feature => {
      const geom = feature.geometry;
      if (geom.type === 'Polygon') {
        geom.coordinates.forEach(ring => ring.forEach(coord => allCoords.push(coord)));
      } else if (geom.type === 'MultiPolygon') {
        geom.coordinates.forEach(polygon => polygon.forEach(ring => ring.forEach(coord => allCoords.push(coord))));
      }
    });

    const lons = allCoords.map(c => c[0]);
    const lats = allCoords.map(c => c[1]);
    const lonMin = Math.min(...lons);
    const lonMax = Math.max(...lons);
    const latMin = Math.min(...lats);
    const latMax = Math.max(...lats);

    const geoWidth = lonMax - lonMin;
    const geoHeight = latMax - latMin;
    const viewWidth = 1000;
    const viewHeight = 700;

    const scaleX = viewWidth / geoWidth;
    const scaleY = viewHeight / geoHeight;
    const scale = Math.min(scaleX, scaleY) * 0.95;

    const offsetXGeo = (viewWidth - geoWidth * scale) / 2;
    const offsetYGeo = (viewHeight - geoHeight * scale) / 2;

    function project([lon, lat]) {
      const x = (lon - lonMin) * scale + offsetXGeo;
      const y = viewHeight - ((lat - latMin) * scale + offsetYGeo);
      return [x, y];
    }

    function coordsToPath(coords) {
      return coords.map(point => project(point).join(',')).join(' ');
    }

    data.features.forEach(feature => {
      const geom = feature.geometry;
      const name = feature.properties?.name || 'Unknown';

      if (geom.type === 'Polygon') {
        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        polygon.setAttribute('points', coordsToPath(geom.coordinates[0]));
        polygon.setAttribute('fill', '#0B3D91');
        polygon.setAttribute('stroke', 'white');
        polygon.setAttribute('stroke-width', 1.5);

        polygon.addEventListener('mouseenter', () => {
          polygon.setAttribute('fill', '#E4002B');
          showTooltip(name);
        });
        polygon.addEventListener('mouseleave', () => {
          polygon.setAttribute('fill', '#0B3D91');
          hideTooltip();
        });
        polygon.addEventListener('mousemove', e => {
          moveTooltip(e.clientX, e.clientY);
        });

        g.appendChild(polygon);
      }
      else if (geom.type === 'MultiPolygon') {
        geom.coordinates.forEach(polygonCoords => {
          const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
          polygon.setAttribute('points', coordsToPath(polygonCoords[0]));
          polygon.setAttribute('fill', '#0B3D91');
          polygon.setAttribute('stroke', 'white');
          polygon.setAttribute('stroke-width', 1.5);

          polygon.addEventListener('mouseenter', () => {
            polygon.setAttribute('fill', '#E4002B');
            showTooltip(name);
          });
          polygon.addEventListener('mouseleave', () => {
            polygon.setAttribute('fill', '#0B3D91');
            hideTooltip();
          });
          polygon.addEventListener('mousemove', e => {
            moveTooltip(e.clientX, e.clientY);
          });

          g.appendChild(polygon);
        });
      }
    });
  }

  function showTooltip(text) {
    tooltip.style.display = 'block';
    tooltip.textContent = text;
  }
  function moveTooltip(x, y) {
    const padding = 10;
    const tooltipRect = tooltip.getBoundingClientRect();
    let left = x + padding;
    let top = y + padding;

    if (left + tooltipRect.width > window.innerWidth) {
      left = x - tooltipRect.width - padding;
    }
    if (top + tooltipRect.height > window.innerHeight) {
      top = y - tooltipRect.height - padding;
    }
    tooltip.style.left = left + 'px';
    tooltip.style.top = top + 'px';
  }
  function hideTooltip() {
    tooltip.style.display = 'none';
  }

  // Zoom & pan handlers
  svg.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomIntensity = 0.1;
    const pt = svg.createSVGPoint();
    pt.x = e.clientX;
    pt.y = e.clientY;
    const cursorpt = pt.matrixTransform(g.getCTM().inverse());

    const direction = e.deltaY > 0 ? 1 : -1;
    const factor = (1 - direction * zoomIntensity);

    zoom *= factor;
    zoom = Math.min(Math.max(zoom, 0.5), 10);

    offsetX = cursorpt.x - (cursorpt.x - offsetX) * factor;
    offsetY = cursorpt.y - (cursorpt.y - offsetY) * factor;

    updateTransform();
  }, { passive: false });

  svg.addEventListener('mousedown', e => {
    isDragging = true;
    dragStart = { x: e.clientX, y: e.clientY };
  });
  window.addEventListener('mouseup', () => {
    isDragging = false;
  });
  window.addEventListener('mousemove', e => {
    if (!isDragging) return;
    e.preventDefault();

    const dx = (e.clientX - dragStart.x) / zoom;
    const dy = (e.clientY - dragStart.y) / zoom;
    offsetX += dx;
    offsetY += dy;
    dragStart = { x: e.clientX, y: e.clientY };

    updateTransform();
  });

  function updateTransform() {
    g.setAttribute('transform', `translate(${offsetX} ${offsetY}) scale(${zoom})`);
  }

  drawMap(data);

})();
</script>

</body>
</html>
